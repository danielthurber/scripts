---
title: "Data Patching"
author: "Daniel Thurber"
date: "7/2/2021"
output: pdf_document
---
```{r}
mypath <- 'C:/Users/Daniel/Documents/Research/data/dataframes/'  #leave this as directory
library(ggplot2)
library(naniar)
sitecodes <- c('LR_FB_BA', 'LR_TG_BA', 'BC_CONF_A', 'TF_CONF_A','RHF_CONF_A',
               'RS_CONF_A', 'TF_SAWM_A', 'SPC_CONF_A', 'LR_WC_A', 'LR_GCB_A')
sitenames <- c('Franklin Basin', 'Tony Grove', 'Beaver Creek', 'Temple Fork', 'Right Hand Fork',
               'Ricks Spring', 'TF at Sawmill', 'Spawn Creek', 'Above Wood Camp', 'Guinavah Campground')
i <- 7

site <- sitecodes[i]               #enter site code for file upload and export
sitename <- sitenames[i]        #enter site name for plotting
paste('Site:', sitecodes[i], '-', sitenames[i])
linecols <- c('brown3', 'goldenrod', 'forestgreen', 'bisque4', 'slateblue', 'sienna3', 'aquamarine3', 'magenta4')
#color vector gets used by other plotting scripts.  Attempt to maintain any changes made to the palette
```


If you are re-opening a previously patched file, do so with this chunk
```{r}
crossdf <- read.csv(paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'))
crossdf$date <- as.Date(crossdf$date,'%Y-%m-%d')

```

Begin by running SNOTEL and LRO_aquatic scripts to generate the qtc and snodf dataframes as .csv files.  This chunk will re-open them.

```{r}
snofile <- 'UDD_1098.csv'
#FB_484, GCS_1114, KN_1115, TF_1013, TGL_823, TGRS_1113, UDD_1098

qtc <- read.csv(paste0(mypath,site,'.csv'), stringsAsFactors = F)
snodf <- read.csv(paste0(mypath,snofile), stringsAsFactors = F)
qtc$date <- as.Date(qtc$date,'%Y-%m-%d')
snodf$Date = as.Date(snodf$Date, format = '%Y-%m-%d')
mindate <- qtc$date[1]
```

This chunk will compile the crossdf dataframe with columns for date, melt, rain, discharge, temp, and conductance
```{r}
crossdf <- data.frame(date = snodf$Date[which(snodf$Date==mindate):nrow(snodf)])
crossdf$melt = snodf$melt[which(snodf$Date==mindate):nrow(snodf)]
crossdf$rain = snodf$rain[which(snodf$Date==mindate):nrow(snodf)]
for (i in 1:nrow(qtc)){
  crossdf$discharge[which(crossdf$date == qtc$date[i])] = qtc$discharge[i]
}
for (i in 1:nrow(qtc)){
  crossdf$conductance[which(crossdf$date == qtc$date[i])] = qtc$conductance[i]
}
for (i in 1:nrow(qtc)){
  crossdf$temp[which(crossdf$date == qtc$date[i])] = qtc$temperature[i]
}
crossdf$SWI <- crossdf$melt+crossdf$rain

crossdf$cpatch <- crossdf$conductance
crossdf$qpatch <- crossdf$discharge
```





```{r}
qholes <- which(is.na(crossdf$qpatch))
mholes <- which(is.na(crossdf$melt))
choles <- which(is.na(crossdf$cpatch))

```

```{r}
paste('discharge:') 
qholes
paste('conductance:')
#choles

```

-------------  Patching Cycle starts here ----------
Generate plots 
```{r}
plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Discharge at', sitename))
abline(v = qholes, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='goldenrod2')


plot(crossdf$cpatch, type = 'l', ylab = 'conductance', main = paste('Conductance at', sitename))
abline(v = choles, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='goldenrod2')

plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Discharge at', sitename),
     xaxt = 'n', xlab = '')
abline(v = qholes, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='goldenrod2')
axis(1, at = seq(1,nrow(crossdf), length.out = 7), 
     labels = (crossdf$date[seq(1,nrow(crossdf),length.out = 7)]))

#plot(crossdf$melt, type = 'l', ylab = 'Melt', main = paste('melt at', sitename))
#abline(v = mholes, col = 'red')
```
Conductance
--- 

Create plot of patched time series and highlight the holes in data (red) and patches (green)
```{r}
#plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Patched discharge at', sitename))
#abline(v = qholes, col = 'red')

plot(crossdf$cpatch, type = 'n', ylab = 'conductance', main = paste('Patched Conductance at', sitename))
abline(v = which(is.na(crossdf$conductance)), col = 'seagreen2')
abline(v = choles, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='goldenrod2')
lines(crossdf$cpatch)

#plot(crossdf$melt, type = 'l', ylab = 'Melt', main = paste('melt at', sitename))
#abline(v = mholes, col = 'red')
```

Zoom in on a section of the conductance plot worth patching



```{r}
patch.int <- c(2130, 2185)

#patch.rng <- range(crossdf$cpatch[patch.int[1]:patch.int[2]], na.rm = T)
#choles

patch.rng <- range(crossdf$cpatch[patch.int[1]:patch.int[2]], na.rm = T)
crossdf$date[mean(patch.int)]
choles

plot(crossdf$cpatch, xlim=patch.int, type= 'l', main = paste(sitename,'centered at',crossdf$date[mean(patch.int)]), ylab = 'conductance')
abline(v = choles, col = 'red')

#plot(crossdf$qpatch, xlim=patch.int, type= 'l', main = sitename, ylab = 'discharge')
#abline(v = qholes, col = 'red')

```

for single patches, run this chunk and enter the index (in console) to interpolate
```{r}
spike <- as.integer(readline(prompt = "Enter index to patch:")) #enter prompt in console
crossdf$cpatch[spike] <- mean(crossdf$cpatch[(spike-1):(spike+1)], na.rm = T) #range can be adjusted
choles <- which(is.na(crossdf$cpatch))
```

find the length of the patch
```{r}
patch.len <-  sum(is.na(crossdf$cpatch[patch.int[1]:patch.int[2]]))
i1 <- 1 #first index of choles to consider
i2 <- 13 #final value of choles to consider
i2 <- i1-1+patch.len
patch.len 
paste('replace from index', choles[i1], 'to', choles[i2])
```


Generate and insert a horizontal noise patch. 
```{r}
patchvals <- runif(i2-i1+1,patch.rng[1], patch.rng[2])  
#patch.rng represents the range of values over the surrounding interval
crossdf$cpatch[choles[i1]:choles[i2]] = patchvals
i1 <- NA
i2 <- NA
```

Generate and insert a linear patch
```{r}
patchvals <- seq(crossdf$cpatch[choles[i1]-1],
                 crossdf$cpatch[choles[i2]+1],
                 length.out = i2-i1+3)
crossdf$cpatch[(choles[i1]-1):(choles[i2]+1)] = patchvals
i1 <- NA
i2 <- NA
```

check the patch
```{r}
plot(crossdf$cpatch, xlim=patch.int, type= 'l', ylab = 'conductance', 
     main = sitename, col = 'seagreen2')
lines(crossdf$conductance, xlim=patch.int)

```
If there was a problem, set up this chunk to undo it (set indices to replace cpatch):
```{r}
j <- patch.int[1]
k <- patch.int[2]

crossdf$cpatch[j:k]=crossdf$conductance[j:k]

```

If it looks good, reset the choles vector
```{r}
choles <- which(is.na(crossdf$cpatch))
choles

```


Save the dataframe for continuation later
```{r}
write.csv(crossdf, paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'), row.names = F)
```



Discharge
---
Create plots of patched time series and highlight the holes in data
```{r}
date.mark <- '10-01' #vertical blue lines will be drawn at this date for reference
plot(crossdf$qpatch, type = 'n', ylab = 'discharge', main = paste('Patched discharge at', sitename))
abline(v = which(is.na(crossdf$discharge)), col = 'seagreen2')
abline(v = qholes, col = 'red')
lines(crossdf$qpatch)
abline(v = which(format(crossdf$date,'%m-%d')==date.mark), col='goldenrod2')
lines(crossdf$discharge1)

#add lines on the defined date to delineate water years
#abline(v = which(format(crossdf$date,'%m-%d')==date.mark), col='cadetblue')

#rgb(78,238,148, alpha = 0, maxColorValue = 255)
```

Zoom in on a section of the discharge plot worth patching

```{r}
patch.int <- c(940, 975)

patch.rng <- range(crossdf$qpatch[patch.int[1]:patch.int[2]], na.rm = T)
#qholes

plot(crossdf$qpatch, xlim=patch.int, ylim = c(0,max(crossdf$qpatch[patch.int[1]:patch.int[2]], na.rm = T)),
     type= 'l', main = paste(sitename,'centered at',crossdf$date[mean(patch.int)]), 
     ylab = 'discharge', col = 'seagreen2')
abline(v = qholes, col = 'red')
lines(crossdf$discharge)

```


for single patches, enter the index (in console) to interpolate
```{r}
spike <- as.integer(readline(prompt = "Enter index to patch:")) #enter prompt in console
crossdf$qpatch[spike] <- mean(crossdf$qpatch[(spike-1):(spike+1)], na.rm = T) #range can be adjusted
qholes <- which(is.na(crossdf$qpatch))
```

find the length of the patch.  Check the third outcome is "TRUE"
```{r}
patch.len <-  sum(is.na(crossdf$qpatch[patch.int[1]:patch.int[2]]))
i1 <- 1 #first index of qholes to consider
i2 <- 6 #final value of qholes to consider
i2 <- i1-1+patch.len
patch.len 
paste('replace from index', qholes[i1], 'to', qholes[i2])
qholes[i2]-qholes[i1]+1-patch.len==0  #this should read TRUE, meaning only one data gap exists
```


-----------------Generate and insert a horizontal noise patch. 
```{r}
patchvals <- runif(i2-i1+1,patch.rng[1], patch.rng[2])  
#patch.rng represents the range of values over the surrounding interval
crossdf$qpatch[qholes[i1]:qholes[i2]] = patchvals
i1 <- NA
i2 <- NA
```




--------------Generate and insert a linear patch
```{r}
patchvals <- seq(crossdf$qpatch[qholes[i1]-1],
                 crossdf$qpatch[qholes[i2]+1],
                 length.out = i2-i1+3)
crossdf$qpatch[(qholes[i1]-1):(qholes[i2]+1)] = patchvals
i1 <- NA
i2 <- NA
```



check the patch
```{r}
plot(crossdf$qpatch, xlim=patch.int, type= 'l', ylab = 'Discharge', main = sitename, 
     ylim = c(0,max(crossdf$qpatch[patch.int[1]:patch.int[2]], na.rm = T)), col = 'seagreen2', xlab = 'date', xaxt = 'n')
lines(crossdf$discharge, xlim=patch.int)
axis(1, at = seq(patch.int[1], patch.int[2], length.out = 6), 
     labels = (crossdf$date[seq(patch.int[1], patch.int[2],length.out = 6)]))


plot(crossdf$qpatch, xlim=patch.int, type= 'l', ylab = 'Discharge', 
     main = sitename, ylim = c(0,max(crossdf$qpatch[patch.int[1]:patch.int[2]], na.rm = T)), col = 'seagreen2')
lines(crossdf$discharge, xlim=patch.int)

```
If there was a problem, try running this chunk to undo it (set a range over which to restore original values)
```{r}
j <- 
k <- 

crossdf$qpatch[j:k]=crossdf$discharge[j:k]

```


If it looks good, reset the qholes vector
```{r}
qholes <- which(is.na(crossdf$qpatch))
qholes[1:10]

```


Save the dataframe for continuation later
```{r}
write.csv(crossdf, paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'), row.names = F)
```

---

-----------Consider an exponential regression model
Create vectors of the values within the patch interval on which to evaluate a regression model
```{r}
reg.vals <- crossdf$qpatch[patch.int[1]:patch.int[2]]
reg.ind <- seq(length.out = length(reg.vals))
```
plot the log-transformed values and a fitted linear model and consider the validity of an exponential patch
```{r}
patch.mod <- lm(log(reg.vals)~reg.ind)
plot(log(reg.vals)~reg.ind)
abline(patch.mod$coefficients)
(patch.mod)
```
 


```{r}
study.int <- c(220,450)
plot(crossdf$melt, xlim = study.int, type = 'l', main = sitename)
plot(crossdf$discharge, xlim = study.int, type = 'l', 
     main = paste('Discharge at',sitename))
abline(v = qholes, col = 'red')

plot(crossdf$conductance, xlim = study.int, type = 'l', ylab = 'Conductance', 
     main = paste('Conductance at', sitename))
abline(v = choles, col = 'red')
```


```{r}
win1 <- c(study.int[1],300)
win2 <- c(study.int[1],330)
win3 <- c(study.int[1],study.int[2])
win4 <- c(260,study.int[2])
win5 <- c(310,study.int[2])
plot(crossdf$discharge, xlim = study.int,
     type = 'n', ylab = '')

rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

lines(crossdf$discharge[study.int[1]:study.int[2]])
```


```{r}
par(mar = c(5,4,4,4) + 0.3)
plot(crossdf$discharge[study.int[1]:study.int[2]], axes = F, type = 'n',
     xlab = '', ylab = '')

rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

par(new = T)
barplot(crossdf$melt[study.int[1]:study.int[2]], ylab = 'melt (in)',
     main = paste('melt and discharge at', sitename), xlab = 'Date')
abline(v = qholes, col = 'red')
abline(v = study.int, lty =5)

par(new = T)
plot(crossdf$discharge[study.int[1]:study.int[2]], 
     type = 'l', axes = F, ylab = '', xlab = '')

axis(4, at = pretty(range(crossdf$discharge[study.int[1]:study.int[2]],na.rm = T)))
mtext("discharge (CMS)", side = 4, line = 3)
axis(1, at = seq(0,diff(study.int), length.out = 6), 
     labels = (crossdf$date[seq(study.int[1],study.int[2],length.out = 6)]))
```

```{r}
a <- study.int[1]  #index of starting time
#a <- 518
c <- 130  #window width (number of days)
b <- a+c    #calculates final index
b <- study.int[2]   #index of ending time
win1 <- c(a,300)
win2 <- c(a,360)
win3 <- c(a,b)
win4 <- c(300,b)
win5 <- c(360,b)
yrange <- c(0,max(qtc$discharge[a:b], na.rm = T))

#plot discharge over the window.  The line gets plotted later over the highlight rectangle
plot(qtc$discharge, xlim = c(a, b), ylim = yrange, type = 'n', ylab = 'discharge', 
     main = paste('discharge at', sitename), xaxt = 'n', xlab = 'date'
     )

#highlight ranges for each window of ACF analysis
rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

#draw and annotate a box around any patches that exist.  Adjust numbers to position vertically
rect(patchstart, 0.5, patchend, 1.5)  #draw a box around patched section of line
text(mean(patchstart,patchend), 0.3, 'Patched values')  #annotate patch box

lines(lin.df$discharge, type = 'l', col = 'red')
lines(qtc$discharge, type = 'l')
axis(1, at = seq(a,b, length.out = 6), labels = (qtc$date[seq(a,b,length.out = 6)]))

```




