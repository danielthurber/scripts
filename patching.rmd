---
title: "Data Patching"
author: "Daniel Thurber"
date: "7/2/2021"
output: pdf_document
---
```{r}
mypath <- 'C:/Users/Daniel/Documents/Research/data/dataframes/'  #leave this as directory
library(ggplot2)
library(naniar)
sitecodes <- c('LR_FB_BA', 'LR_TG_BA', 'BC_CONF_A', 'TF_CONF_A','RHF_CONF_A',
               'RS_CONF_A', 'TF_SAWM_A', 'SPC_CONF_A', 'LR_WC_A', 'LR_GCB_A')
sitenames <- c('Franklin Basin', 'Tony Grove', 'Beaver Creek', 'Temple Fork', 'Right Hand Fork',
               'Ricks Spring', 'TF at Sawmill', 'Spawn Creek', 'Above Wood Camp', 'Guinavah Campground')
i <- 1

snofile <- 'TF_1013.csv'
#FB_484, GCS_1114, KN_1115, TF_1013, TGL_823, TGRS_1113, UDD_1098
site <- sitecodes[i]               #enter site code for file upload and export
sitename <- sitenames[i]        #enter site name for plotting
paste('Site:', sitecodes[i], '-', sitenames[i])
linecols <- c('brown3', 'goldenrod', 'forestgreen', 'bisque4', 'slateblue', 'sienna3', 'aquamarine3', 'magenta4')
#color vector gets used by other plotting scripts.  Attempt to maintain any changes made to the palette
```


If you are re-opening a previously patched file, do so with this chunk
```{r}
crossdf <- read.csv(paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'))
crossdf$date <- as.Date(crossdf$date,'%Y-%m-%d')

```

Begin by running SNOTEL and LRO_aquatic scripts to generate the qtc and snodf dataframes as .csv files.  This chunk will re-open them.

```{r}
qtc <- read.csv(paste0(mypath,site,'.csv'), stringsAsFactors = F)
snodf <- read.csv(paste0(mypath,snofile), stringsAsFactors = F)
qtc$date <- as.Date(qtc$date,'%Y-%m-%d')
snodf$Date = as.Date(snodf$Date, format = '%Y-%m-%d')
mindate <- qtc$date[1]
```

This chunk will compile the crossdf dataframe with columns for date, melt, rain, discharge, temp, and conductance
```{r}
crossdf <- data.frame(date = snodf$Date[which(snodf$Date==mindate):nrow(snodf)])
crossdf$melt = snodf$melt[which(snodf$Date==mindate):nrow(snodf)]
crossdf$rain = snodf$rain[which(snodf$Date==mindate):nrow(snodf)]
for (i in 1:nrow(qtc)){
  crossdf$discharge[which(crossdf$date == qtc$date[i])] = qtc$discharge[i]
}
for (i in 1:nrow(qtc)){
  crossdf$conductance[which(crossdf$date == qtc$date[i])] = qtc$conductance[i]
}
for (i in 1:nrow(qtc)){
  crossdf$temp[which(crossdf$date == qtc$date[i])] = qtc$temperature[i]
}
crossdf$SWI <- crossdf$melt+crossdf$rain
```

This section looks at holes in the data and patches them.  It requires running the "correlograms" script far enough to create the "crossdf" object.  The section on ACF generation in that script can be skipped over.  

The output of this file will be a new .csv file with updated columns to include patched data.

---



Add columns to the crossdf dataframe for patched versions of data
```{r}
crossdf$cpatch <- crossdf$conductance
crossdf$qpatch <- crossdf$discharge
```
```{r}
qholes <- which(is.na(crossdf$qpatch))
mholes <- which(is.na(crossdf$melt))
choles <- which(is.na(crossdf$cpatch))

```

```{r}
qholes
choles

```

-------------  Patching Cycle starts here ----------
Generate plots 
```{r}
plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Discharge at', sitename))
abline(v = qholes, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='cadetblue')


plot(crossdf$cpatch, type = 'l', ylab = 'conductance', main = paste('Conductance at', sitename))
abline(v = choles, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='cadetblue')

#plot(crossdf$melt, type = 'l', ylab = 'Melt', main = paste('melt at', sitename))
#abline(v = mholes, col = 'red')
```
Conductance
--- 

Create plot of patched time series and highlight the holes in data
```{r}
#plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Patched discharge at', sitename))
#abline(v = qholes, col = 'red')

plot(crossdf$cpatch, type = 'l', ylab = 'conductance', main = paste('Patched Conductance at', sitename))
abline(v = choles, col = 'red')
abline(v = which(format(crossdf$date,'%m-%d')=='10-01'), col='cadetblue')

#plot(crossdf$melt, type = 'l', ylab = 'Melt', main = paste('melt at', sitename))
#abline(v = mholes, col = 'red')
```

Zoom in on a section of the conductance plot worth patching

```{r}
patch.int <- c(1725,1735)

#patch.rng <- range(crossdf$cpatch[patch.int[1]:patch.int[2]], na.rm = T)
#choles

patch.rng <- range(crossdf$cpatch[patch.int[1]:patch.int[2]], na.rm = T)


plot(crossdf$cpatch, xlim=patch.int, type= 'l', main = sitename, ylab = 'conductance')
abline(v = choles, col = 'red')

#plot(crossdf$qpatch, xlim=patch.int, type= 'l', main = sitename, ylab = 'discharge')
#abline(v = qholes, col = 'red')

```
find the length of the patch
```{r}
patch.len <-  sum(is.na(crossdf$cpatch[patch.int[1]:patch.int[2]]))
patch.len 
```

Create vectors of the values within the patch interval on which to evaluate a regression model
```{r}
reg.vals <- crossdf$cpatch[patch.int[1]:patch.int[2]]
reg.ind <- seq(length.out = length(reg.vals))
```

plot the log-transformed values and a fitted linear model and consider the validity of an exponential patch
```{r}
patch.mod <- lm(log(reg.vals)~reg.ind)
plot(log(reg.vals)~reg.ind)
abline(patch.mod$coefficients)
(patch.mod)
```
 

Generate and insert a horizontal noise patch. 
i1 and i2 values must be set each time!!!! 

```{r}

i1 <- 1 #first index of choles to consider
i2 <- 6 #final value of choles to consider
i2 <- i1-1+patch.len #if i1 = 1, this will automatically set the interval
patchvals <- runif(i2-i1+1,patch.rng[1], patch.rng[2])  
#patch.rng represents the range of values over the surrounding interval
crossdf$cpatch[choles[i1]:choles[i2]] = patchvals
```

Generate and insert a linear patch
i1 and i2 values MUST BE SET EACH TIME!!!
```{r}
i1 <- 1 #first index of choles to consider
i2 <- 13 #final value of choles to consider
i2 <- i1-1+patch.len
patchvals <- seq(crossdf$cpatch[choles[i1]-1],
                 crossdf$cpatch[choles[i2]+1],
                 length.out = i2-i1+3)
crossdf$cpatch[(choles[i1]-1):(choles[i2]+1)] = patchvals
```

check the patch
```{r}
plot(crossdf$cpatch, xlim=patch.int, type= 'l', ylab = 'conductance', 
     main = sitename, col = 'red')
lines(crossdf$conductance, xlim=patch.int)

```
If there was a problem, set up this chunk to undo it (set indices to replace cpatch):
```{r}
j <- 230
k <- 235

crossdf$cpatch[j:k]=crossdf$conductance[j:k]

```

If it looks good, reset the choles vector
```{r}
choles <- which(is.na(crossdf$cpatch))
choles

```


Save the dataframe for continuation later
```{r}
write.csv(crossdf, paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'), row.names = F)
```



Discharge
---
Create plots of patched time series and highlight the holes in data
```{r}
date.mark <- '03-15' #vertical blue lines will be drawn at this date for reference
plot(crossdf$qpatch, type = 'l', ylab = 'discharge', main = paste('Patched discharge at', sitename))
abline(v = qholes, col = 'red')

#add lines on the defined date to delineate water years
#abline(v = which(format(crossdf$date,'%m-%d')==date.mark), col='cadetblue')


```

Zoom in on a section of the discharge plot worth patching

```{r}
patch.int <- c(282,291)

patch.rng <- range(crossdf$qpatch[patch.int[1]:patch.int[2]], na.rm = T)
qholes

plot(crossdf$qpatch, xlim=patch.int, type= 'l', main = sitename, ylab = 'discharge')
abline(v = qholes, col = 'red')

```
find the length of the patch
```{r}
patch.len <-  sum(is.na(crossdf$qpatch[patch.int[1]:patch.int[2]]))
patch.len 
```


-----------Consider an exponential regression model

Create vectors of the values within the patch interval on which to evaluate a regression model
```{r}
reg.vals <- crossdf$qpatch[patch.int[1]:patch.int[2]]
reg.ind <- seq(length.out = length(reg.vals))
```

plot the log-transformed values and a fitted linear model and consider the validity of an exponential patch
```{r}
patch.mod <- lm(log(reg.vals)~reg.ind)
plot(log(reg.vals)~reg.ind)
abline(patch.mod$coefficients)
(patch.mod)
```
 

-----------------Generate and insert a horizontal noise patch. 
i1 and i2 values must be set each time!!!!

```{r}

i1 <- 1 #first index of qholes to consider
i2 <- 6 #final value of qholes to consider
i2 <- i1-1+patch.len

patchvals <- runif(i2-i1+1,patch.rng[1], patch.rng[2])  
#patch.rng represents the range of values over the surrounding interval
crossdf$qpatch[qholes[i1]:qholes[i2]] = patchvals
```



--------------Generate and insert a linear patch
i1 and i2 values MUST BE SET EACH TIME!!!
```{r}
i1 <- 1 #first index of qholes to consider
i2 <- 6 #final value of qholes to consider
i2 <- i1-1+patch.len
patchvals <- seq(crossdf$qpatch[qholes[i1]-1],
                 crossdf$qpatch[qholes[i2]+1],
                 length.out = i2-i1+3)
crossdf$qpatch[(qholes[i1]-1):(qholes[i2]+1)] = patchvals
```

check the patch
```{r}
plot(crossdf$qpatch, xlim=patch.int, type= 'l', ylab = 'Discharge', 
     main = sitename, col = 'red')
lines(crossdf$discharge, xlim=patch.int)

```
If there was a problem, try running this chunk to undo it (set a range over which to restore original values:
```{r}
j <- 
k <- 

crossdf$qpatch[j:k]=crossdf$discharge[j:k]

```


If it looks good, reset the qholes vector
```{r}
qholes <- which(is.na(crossdf$qpatch))
qholes

```


Save the dataframe for continuation later
```{r}
write.csv(crossdf, paste0('C:/Users/Daniel/Documents/Research/data/dataframes/patched_data/',site,'_patched.csv'), row.names = F)
```

---
```{r}
study.int <- c(220,450)
plot(crossdf$melt, xlim = study.int, type = 'l', main = sitename)
plot(crossdf$discharge, xlim = study.int, type = 'l', 
     main = paste('Discharge at',sitename))
abline(v = qholes, col = 'red')

plot(crossdf$conductance, xlim = study.int, type = 'l', ylab = 'Conductance', 
     main = paste('Conductance at', sitename))
abline(v = choles, col = 'red')
```


```{r}
win1 <- c(study.int[1],300)
win2 <- c(study.int[1],330)
win3 <- c(study.int[1],study.int[2])
win4 <- c(260,study.int[2])
win5 <- c(310,study.int[2])
plot(crossdf$discharge, xlim = study.int,
     type = 'n', ylab = '')

rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

lines(crossdf$discharge[study.int[1]:study.int[2]])
```


```{r}
par(mar = c(5,4,4,4) + 0.3)
plot(crossdf$discharge[study.int[1]:study.int[2]], axes = F, type = 'n',
     xlab = '', ylab = '')

rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

par(new = T)
barplot(crossdf$melt[study.int[1]:study.int[2]], ylab = 'melt (in)',
     main = paste('melt and discharge at', sitename), xlab = 'Date')
abline(v = qholes, col = 'red')
abline(v = study.int, lty =5)

par(new = T)
plot(crossdf$discharge[study.int[1]:study.int[2]], 
     type = 'l', axes = F, ylab = '', xlab = '')

axis(4, at = pretty(range(crossdf$discharge[study.int[1]:study.int[2]],na.rm = T)))
mtext("discharge (CMS)", side = 4, line = 3)
axis(1, at = seq(0,diff(study.int), length.out = 6), 
     labels = (crossdf$date[seq(study.int[1],study.int[2],length.out = 6)]))
```

```{r}
a <- study.int[1]  #index of starting time
#a <- 518
c <- 130  #window width (number of days)
b <- a+c    #calculates final index
b <- study.int[2]   #index of ending time
win1 <- c(a,300)
win2 <- c(a,360)
win3 <- c(a,b)
win4 <- c(300,b)
win5 <- c(360,b)
yrange <- c(0,max(qtc$discharge[a:b], na.rm = T))

#plot discharge over the window.  The line gets plotted later over the highlight rectangle
plot(qtc$discharge, xlim = c(a, b), ylim = yrange, type = 'n', ylab = 'discharge', 
     main = paste('discharge at', sitename), xaxt = 'n', xlab = 'date'
     )

#highlight ranges for each window of ACF analysis
rect(xleft=win1[1], xright=win1[2], ybottom = 0, ytop=.2*yrange[2],  col = linecols[1])
rect(xleft=win2[1], xright=win2[2], ybottom = .2*yrange[2], ytop=.4*yrange[2],  col = linecols[2])
rect(xleft=win3[1], xright=win3[2], ybottom = .4*yrange[2], ytop=.6*yrange[2],  col = linecols[3])
rect(xleft=win4[1], xright=win4[2], ybottom = .6*yrange[2], ytop=.8*yrange[2],  col = linecols[4])
rect(xleft=win5[1], xright=win5[2], ybottom = .8*yrange[2], ytop=1*yrange[2],  col = linecols[5])

#draw and annotate a box around any patches that exist.  Adjust numbers to position vertically
rect(patchstart, 0.5, patchend, 1.5)  #draw a box around patched section of line
text(mean(patchstart,patchend), 0.3, 'Patched values')  #annotate patch box

lines(lin.df$discharge, type = 'l', col = 'red')
lines(qtc$discharge, type = 'l')
axis(1, at = seq(a,b, length.out = 6), labels = (qtc$date[seq(a,b,length.out = 6)]))

```




